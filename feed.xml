<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://laurie-hxf.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://laurie-hxf.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-03T17:52:20+00:00</updated><id>https://laurie-hxf.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">How to use clash on linux</title><link href="https://laurie-hxf.github.io/blog/2024/How-to-use-clash-in-linux/" rel="alternate" type="text/html" title="How to use clash on linux"/><published>2024-11-07T13:00:00+00:00</published><updated>2024-11-07T13:00:00+00:00</updated><id>https://laurie-hxf.github.io/blog/2024/How-to-use-clash-in-linux</id><content type="html" xml:base="https://laurie-hxf.github.io/blog/2024/How-to-use-clash-in-linux/"><![CDATA[<p>本博客基于这个<a href="https://docs.gtk.pw/contents/linux/linux-clash-gui.html#下载">博客</a></p> <p>上面的博客已经讲的非常清晰</p> <p>本博客只是在此基础上补充些细节</p> <h3 id="设备">设备</h3> <p>x86架构 ubuntun24</p> <h3 id="下载">下载</h3> <ul> <li><a href="https://app.box.com/s/my3vtk7cxefp7v69vsnzg3kebehqba1x/folder/211969947230">box</a></li> </ul> <p>根据电脑的架构下载对应的版本</p> <p>但是根据自己的经验似乎这个网址本身就是要vpn才能连接</p> <p>linux下好像是无法打开这个网址的</p> <p>如果是这样的话，建议用另外一台可以登上这个网址的电脑先下载这个文件，然后将文件传给linux</p> <p>这里我们用scp(基于ssh的安全传输方式)</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp file.txt user@remote_host:/home/user/
</code></pre></div></div> <p>file.txt就是要传输的那个文件</p> <p>user@remote_host就是要传输的那台电脑</p> <p>对于小白而言，user其实就是主机名，可以打开linux终端，输入</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">whoami</span>
</code></pre></div></div> <p>来查看主机名</p> <p>对于remote_host就是要传输对象的ip地址</p> <p>可以用</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip addr show
</code></pre></div></div> <p>进行查看,一般就在wlo1那里查看，一般长10.xx…之类的就是</p> <h3 id="配置">配置</h3> <p>当你成功传输之后，打开tar文件，图形化界面直接就帮你解压，不行就tar命令</p> <p>进入文件中之后就直接点击cfw文件，然后他就有clash的图形化界面</p> <p>点击左边<code class="language-plaintext highlighter-rouge">profiles</code>，在搜索栏输入购买流量的url（流量当然是购买来的），然后按个回车就能导入</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/vpn1-480.webp 480w,/assets/img/vpn1-800.webp 800w,/assets/img/vpn1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/vpn1.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>订阅成功之后就选中刚刚导入的内容</p> <h3 id="设置系统代理">设置系统代理</h3> <p>由于 Clash for Windows 的系统代理功能只在 Windows 和 macOS 下生效，所以在 Linux 下需要手动设置系统代理。</p> <p>在系统设置中，找到网络设置。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/vpn2-480.webp 480w,/assets/img/vpn2-800.webp 800w,/assets/img/vpn2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/vpn2.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>点开代理</p> <p>打开，然后选择手动</p> <p>按图中配置</p> <p>127.0.0.1是本地主机号，7890是clash选择的端口号</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/vpn3-480.webp 480w,/assets/img/vpn3-800.webp 800w,/assets/img/vpn3-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/vpn3.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/vpn4-480.webp 480w,/assets/img/vpn4-800.webp 800w,/assets/img/vpn4-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/vpn4.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>自己可以在proxies选择不同的流量</p> <p>打开<code class="language-plaintext highlighter-rouge">Allow lan</code>就可以使用</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="其他"/><summary type="html"><![CDATA[vpn for clash]]></summary></entry><entry><title type="html">Discrete Mathematics lecture4</title><link href="https://laurie-hxf.github.io/blog/2024/Discrete-Mathematics-lecture4-NP/" rel="alternate" type="text/html" title="Discrete Mathematics lecture4"/><published>2024-10-19T11:46:00+00:00</published><updated>2024-10-19T11:46:00+00:00</updated><id>https://laurie-hxf.github.io/blog/2024/Discrete-Mathematics-lecture4-NP</id><content type="html" xml:base="https://laurie-hxf.github.io/blog/2024/Discrete-Mathematics-lecture4-NP/"><![CDATA[<p>NP问题是一系列的不知道是否存在有效解决办法的问题 然后如果知道了其中一个的问题的有效解法，那么所有的NP问题就都有有效的解决办法</p> <h4 id="input-size-of-problems">Input size of problems</h4> <p>input size of problems是对问题输入进行编码所需要的bit数，例如当输入一个数进入函数的时候，计算机通常解决的是这个数的二进制那么input size of problems通常是$\log_2 n$</p> <h4 id="decision-problem-optimization-problem">Decision problem&amp; Optimization problem</h4> <h6 id="decision-problem决策问题">Decision problem决策问题</h6> <p>a problem that has a yes or no answer eg.Given n&gt;0, is integer m such that $m^m&lt;n$?</p> <h6 id="optimization-problem优化问题">Optimization problem优化问题</h6> <p>a problem that asks for some answer that maximizes or minimizes a particular objective function eg.Given n&gt;0, what is the largest integer m such that $m^m&lt;n$?</p> <h4 id="polynomial-time-algorithms">Polynomial-Time Algorithms</h4> <p>an algorithm that runs in time $O(n^c)$where c&gt;0 is a constant number independent of n and n is the input size of the problem that the algorithms</p> <h4 id="non-polynomial-time-algorithms">Non-Polynomial-Time Algorithms</h4> <p>an algorithm of which the running time is not $O(n^c)$for any constant c&gt;0. 比如$O(2^n),O(n!)$等等</p> <h4 id="p类">P类</h4> <p>就是对于一个Decision problem，可以用Polynomial-Time Algorithms来解决它，这类Decision problem的集合就是P类</p> <h4 id="np类">NP类</h4> <p>还是对于一个Decision problem，不一定能够用Polynomial-Time Algorithms来找到一个解，但可以用Polynomial-Time来验证一个解是不是正确的</p> <h4 id="psubseteq-np">$P\subseteq NP$</h4> <p>证明这个很简单，就是如果一个解可以在Polynomial-Time解出来，那么它一定可以在Polynomial-Time被验证 但是反过来证明$NP\subseteq P$这个就不知道，因为如果一个解可以在Polynomial-Time内被验证，那么它是否一定能在Polynomial-Time时间内解出来呢</p> <p>所以这就是著名的P=NP问题</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="数学"/><summary type="html"><![CDATA[NP problem]]></summary></entry><entry><title type="html">computer network application</title><link href="https://laurie-hxf.github.io/blog/2024/computer-network-application/" rel="alternate" type="text/html" title="computer network application"/><published>2024-10-19T08:01:00+00:00</published><updated>2024-10-19T08:01:00+00:00</updated><id>https://laurie-hxf.github.io/blog/2024/computer-network-application</id><content type="html" xml:base="https://laurie-hxf.github.io/blog/2024/computer-network-application/"><![CDATA[<h3 id="client-sever-architectureweb-email">client-sever architecture(web, email)</h3> <h5 id="sever">sever:</h5> <ul> <li>always on host</li> <li>固定的ip地址 <h5 id="client">client</h5> </li> <li>可以有动态的ip地址</li> <li>跟sever来进行交流，不直接与client交流</li> </ul> <h3 id="peer-to-peer-architecturep2p">peer to peer architecture(P2P)</h3> <p>peer之间相互传文件</p> <p>end system中每一个进程来对message进行发送和接受 每个进程通过sockets来发送和接受 内部的进程间相互交流通过inter-process communication（defined by OS）</p> <h3 id="sockets">sockets</h3> <p>就是当一个进程想要访问外部资源时，os会帮这个进程创建一个socket，这个socket包含ip+端口+协议（tcp/ udp）这里的端口是os帮忙创建的临时端口，每个进程的端口号是不一样的，然后在同一台设备下运行的process的ip是一样的</p> <p>这个socket还会包含目标的ip和端口号，这里的端口号一般都是固定的 比如HTTP：80 HTTPS：443 比如我有两个运行在同一台设备的两个process要访问相同的一个网址</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>			不同进程的socket						example.com
• 进程A：&lt;192.168.1.10, 12345, TCP&gt; → &lt;93.184.216.34, 443, TCP&gt;
• 进程B：&lt;192.168.1.10, 12346, TCP&gt; → &lt;93.184.216.34, 443, TCP&gt;
然后目标服务器根据传输来的socket将数据传回去
</code></pre></div></div> <h3 id="选择tcp还是udp">选择TCP还是UDP</h3> <h4 id="tcp">TCP：</h4> <ul> <li>他要先与sever建立联系（三次握手）</li> <li>更reliable</li> <li>但是更慢 <h4 id="udp">UDP：</h4> </li> <li>更快 主要适用于直播或其他那种追求响应速度的需求</li> </ul> <h3 id="web">WEB</h3> <p>web基于http/https然后也基于tcp协议，因为web不想丢包 URL相当于网址</p> <h3 id="http">HTTP</h3> <ul> <li>non-persistent HTTP 一次tcp连接只能传一个文件，要下载多个文件就需要建立多次tcp连接</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/19-480.webp 480w,/assets/img/19-800.webp 800w,/assets/img/19-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/19.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <ul> <li>persistent HTTP 一次tcp连接可以传多个文件</li> </ul> <p>HTTP请求的header message</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/20-480.webp 480w,/assets/img/20-800.webp 800w,/assets/img/20-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/20.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>HTTP的response message status code状态码 200 OK 400 not found…</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/21-480.webp 480w,/assets/img/21-800.webp 800w,/assets/img/21-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/21.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h4 id="cookie">cookie</h4> <p>http没有记忆（stateless）意思就是如果你重复两次请求同一个网页，http不会记住你之前的一些行为，比如如果去购物网站，你添加商品进购物车，这时候你的下一次再访问你讲无法看到你先前添加的商品 这时候就产生cookie他用来记录用户的一些信息，当第一次访问一个网站时，web就会给你分配一个cookie id生成一个数据库，记录你在网站的一些喜好，信息之类的。然后当下一次请求同一个网站时，你的浏览器就会在你的请求里加上这个cookie那么sever就知道对应的喜好，不用再重新配置像语言等的喜好</p> <h4 id="web-cachesproxy代理server">Web caches：proxy（代理）server</h4> <p>就将原sever的一些内容缓存到proxy server中，当想要访问某个页面，就可以直接向proxy sever请求，如果有就直接返回，不用再访问origin sever</p> <ul> <li>减轻origin sever的load</li> <li>更快 但这样会有一个问题就是有可能cache中的内容out of date 那么这时候proxy sever可能就要向原sever发送请求保障自己的内容是up to date 但是具体多久检查一次之类就由程序编写决定</li> </ul> <h3 id="electronic-mail">Electronic Mail</h3> <p>user agents(邮箱软件) mail servers mail servers要一直运行，不然将无法接收到邮件，这也是必须要有mail sever的原因，不然的话就要让用户的电脑一直保持开机 如果直接让alice发邮件给bob的sever这样邮件可能发送失败，然后用户需要自己一遍遍重新发，如果有了sever就可以让sever来发，同时如果bob想要发送邮件给Alice那么他是发不过去的 还有就是mail sever不是一收到邮件就讲邮件传给用户电脑，而是当用户需要查看邮件打开user agents时server才将邮件传给用户电脑</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/22-480.webp 480w,/assets/img/22-800.webp 800w,/assets/img/22-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/22.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="smtp">SMTP</h3> <p>使用TCP协议，在进行TCP的三次握手之后，SMTP也有三次handshaking 220表示sever已经准备好接受邮件了 250表示请求成功</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/23-480.webp 480w,/assets/img/23-800.webp 800w,/assets/img/23-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/23.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>SMTP中的header和body都是ASCII码</p> <h4 id="mail-access-protocols">Mail access protocols</h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/24-480.webp 480w,/assets/img/24-800.webp 800w,/assets/img/24-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/24.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>bob的sever将邮件给bob电脑不能是smtp协议因为smtp是一个push的过程，这就要求bob的电脑要一直开机，所以这是就要用HTTP类似的协议因为这是一个pull的过程</p> <h3 id="dns">DNS</h3> <p>domain name system 就是将ip地址和网址map的数据库 他还可以将一长串网址的别名（alias）和原网址map起来 他还可以分担服务器的压力 因为一个网站可能有多个服务器支持，那么他就有多个ip，dns可以将这个网址和这些多个ip map起来将访问者分配到不同的ip上面以此来分担压力</p> <h4 id="dns的分层结构">dns的分层结构</h4> <ul> <li>root DNS severs（根据想要网址的后缀.com.org…进行区分，指出对应的TLD服务器）</li> <li>TLD severs</li> <li>Authoritative DNS servers</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/25-480.webp 480w,/assets/img/25-800.webp 800w,/assets/img/25-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/25.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <ul> <li>Local DNS server 相当于一个缓存，存一些已经知道对应ip的网址，这样用户电脑要访问某个网站的时候，就可以直接问local dns server有没有，如果有就不用在问local dns sever了</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/26-480.webp 480w,/assets/img/26-800.webp 800w,/assets/img/26-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/26.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/27-480.webp 480w,/assets/img/27-800.webp 800w,/assets/img/27-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/27.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> left:iterated query right:recursive query </div> <h4 id="dns-records">DNS records</h4> <p>distributed database storing resource records（RR） 可以理解为dns存储的不同类型数据</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/28-480.webp 480w,/assets/img/28-800.webp 800w,/assets/img/28-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/28.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>如果DNS是authoritative那么他存储的类型就是Type A 对于not authoritative 他应该有一个Type NS和一个Type A</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/29-480.webp 480w,/assets/img/29-800.webp 800w,/assets/img/29-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/29.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/30-480.webp 480w,/assets/img/30-800.webp 800w,/assets/img/30-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/30.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="p2p">P2P</h3> <p>他和client-server的传输延时差别</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/31-480.webp 480w,/assets/img/31-800.webp 800w,/assets/img/31-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/31.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/32-480.webp 480w,/assets/img/32-800.webp 800w,/assets/img/32-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/32.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h4 id="p2p-file-distribution-bittorrent">P2P file distribution ：bitTorrent</h4> <p>将文件分为一个个chunks peers在bitTorrent中发送和接受文件的chunks 在发送和接受时，peer可以随时离开和进来</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 发布文件：当一个用户想要共享某个文件时，他们会生成一个包含文件信息的 **torrent 文件**。这个文件包含了 tracker 的 URL 以及该文件的哈希值等元数据。

2. 连接 tracker：当其他用户想要下载该文件时，他们会通过下载到的 torrent 文件获取到 tracker 的地址，客户端软件会向 tracker 发出一个请求，询问有哪些 peers 拥有该文件。

3. 获取 peers 列表：Tracker 接收到请求后，返回一组活跃的 peers（这些 peers 持有部分或全部文件）。

4. 连接 peers：客户端收到 peers 列表后，开始直接与这些 peers 建立连接，下载或上传文件。

5. 汇报状态：在下载过程中，客户端会定期向 tracker 汇报自己的状态（例如下载进度、是否依然在线），以帮助 tracker 维护最新的网络状态。
</code></pre></div></div> <p>P2P中有两个主要问题：</p> <ul> <li>每个peer传送不同的chunks，我应该先接受哪个chunks呢 先接收稀有的</li> <li>如果有多个neighbors向我请求，我应该先给谁呢 谁帮我最多我就先帮他</li> </ul> <h3 id="video-streaming">Video Streaming</h3> <p>视频就是一系列图片 Coding（Compression）编码（压缩）</p> <ol> <li>spatial：对于照片中有一部分是相同颜色，相比于记录每个像素是什么颜色，不如直接记录这个颜色从第几行到第几行</li> <li>对于连续两张图片而言，与其分别记录两张图片的信息，不如记录其中一张的信息和两张图片之间的差别 video bitrate：视频比特率（视频每秒传输的比特数，通常以 Mbps（百万位每秒）为单位。比特率越高，视频质量越好，但占用的带宽也更大。） Frame rate：帧率</li> </ol> <h4 id="dash">DASH</h4> <p>通常用于在线视频平台或流媒体服务，DASH sever将视频文件切割成许多小的时间片段（通常几秒钟长）。这些片段被独立存储在服务器上，客户端（DASH Client）可以根据需要请求不同质量的片段进行播放。</p> <p>当用户开始播放视频时，DASH Client（例如网页播放器或视频应用）会根据当前的网络条件选择适当的片段进行下载和播放。如果网络状况较好，客户端会下载高分辨率的片段；如果网络状况较差，客户端则会切换到较低分辨率的片段，以避免缓冲或卡顿现象。</p> <p>DASH只在流媒体平台中应用，和将视频下载之后再下载不同，DASH就像用视频平台的自动清晰度，根据网络动态调整画面的清晰度以此保证视频的流畅度。而将视频下载之后再看需要一开始就确定视频的清晰度，并且播放时无法改变清晰度。</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="cs"/><summary type="html"><![CDATA[application]]></summary></entry><entry><title type="html">computer network introduction</title><link href="https://laurie-hxf.github.io/blog/2024/computer-network-Introduction/" rel="alternate" type="text/html" title="computer network introduction"/><published>2024-10-19T03:01:00+00:00</published><updated>2024-10-19T03:01:00+00:00</updated><id>https://laurie-hxf.github.io/blog/2024/computer-network-Introduction</id><content type="html" xml:base="https://laurie-hxf.github.io/blog/2024/computer-network-Introduction/"><![CDATA[<h4 id="some-basic-word-about-computer-network">some basic word about computer network</h4> <p>host(主机)=end system servers(服务器) Routers(路由器) Switches(交换机) Protocols(协议) ISP(Internet Service Provider)</p> <h5 id="protocols">protocols</h5> <p>Application :IMAP,SMTP,HTTP Transport:TCP,UDP Network:IP Link Physical</p> <h5 id="internet-structure">Internet structure:</h5> <p>Network edge:runs network applications网络边缘</p> <ul> <li>client/server model(web browser/server; email)</li> <li>peer-peer model(BitTorrent)</li> </ul> <p>Access networks, physical media接入网 将设备连接到第一个routers</p> <p>Network core网络核心</p> <h5 id="packets">Packets</h5> <p>将要传输的文件分为一个个更小的单位packets，他的长度为L，将这个packet传送到access network所需的transmission rate R（又叫link capacity，bandwidth带宽） 那没传输延迟就是 \(packet \: transmission\: delay=\frac{L(bits)}{R(bits/sec)}\)</p> <h5 id="access-net">Access net</h5> <p>cable network用电缆传输数据 digital subscriber line(DSL)用电话线来传</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/13-480.webp 480w,/assets/img/13-800.webp 800w,/assets/img/13-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/13.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h5 id="the-network-core">The network core</h5> <p><mark>Packet switching</mark></p> <ul> <li>store and forward(packet是按照bit来进行传输，一个路由器必须接受完一个packet之后才可以将这个packet传输出去)</li> <li>packet is transmitted at full link capacity</li> <li>not reserved packet switching衍生出的两个问题，如果一个packet传入到一个路由器的速度大于他传输出去的速度，那必然会在output buffer中引起排队(queuing delay)，如果排队的数据过多，他会超出output buffer的容量，产生丢包(packet loss)</li> </ul> <p><mark>forwarding and routing</mark> 每个路由器中间都有一个转发表(forwarding table)当数据从输入端口时，路由器根据数据包的表头之类的信息将packet输出到路由器合适的端口</p> <p>路由(routing)他是全局的作用，寻找一个从source到destination中最合适（最快maybe）的路径（路由器线路）然后将这些信息写入转发表中，然后路由器根据转发表将数据传输出去</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/14-480.webp 480w,/assets/img/14-800.webp 800w,/assets/img/14-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/14.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><mark>Circuit switching</mark> 每两个设备之间拉一根线，那么对于每一个设备他就要有n根线 保障线路不被占用但非常浪费</p> <h5 id="isp">ISP</h5> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/15-480.webp 480w,/assets/img/15-800.webp 800w,/assets/img/15-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/15.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> ISP </div> <h5 id="performance-metric性能指标">Performance Metric(性能指标)</h5> <ol> <li>delay(时延) <ul> <li>nodal 就是packet经过一个路由器到下一个路由器的总时间 $d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$ 总时延=处理时延（路由器检查packet报文头，确定转发路径）+排队时延+传输时延($\frac{L}{R}$)+传播时延（就是数据从路由器到另一个路由器之间物理链路的时延）</li> <li>end to end 就是从source到destination的总时间 $\sum_{i=1}^{N} (nodal:delay:of:nodal:i)$</li> </ul> <blockquote> <p>queueing delay:</p> <p>traffic intensity =$\frac{L\lambda}{R}$ L是每个packet有多少bits $\lambda$是平均每秒有多少packets到达这个路由器 R是transmissions rate</p> <p>如果traffic intensity趋近于0意味着他的queueing delay非常的小 如果接近与1意味着他的queueing delay趋于无穷 如果大于1那么意味着他的时延是无穷</p> </blockquote> </li> <li>packet loss(丢包)</li> <li>Throughput(吞吐量) 比特传输的速度 <ul> <li>instantaneous瞬时</li> <li>average（整个链路中最小的transmission rate R）</li> </ul> </li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/16-480.webp 480w,/assets/img/16-800.webp 800w,/assets/img/16-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/16.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h5 id="internet-protocol-stack">Internet protocol stack</h5> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/17-480.webp 480w,/assets/img/17-800.webp 800w,/assets/img/17-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/17.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Internet protocol stack </div> <h5 id="encapsulation封装">Encapsulation（封装）</h5> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/18-480.webp 480w,/assets/img/18-800.webp 800w,/assets/img/18-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/18.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Encapsulation </div>]]></content><author><name></name></author><category term="sample-posts"/><category term="cs"/><summary type="html"><![CDATA[introduction]]></summary></entry><entry><title type="html">How to build NAS</title><link href="https://laurie-hxf.github.io/blog/2024/How-to-build-NAS/" rel="alternate" type="text/html" title="How to build NAS"/><published>2024-10-19T02:22:00+00:00</published><updated>2024-10-19T02:22:00+00:00</updated><id>https://laurie-hxf.github.io/blog/2024/How-to-build-NAS</id><content type="html" xml:base="https://laurie-hxf.github.io/blog/2024/How-to-build-NAS/"><![CDATA[<p>该博客主要介绍如何利用一台电脑+机械硬盘来搭建一台可以随地访问的nas</p> <h4 id="配置"><strong>配置：</strong></h4> <p>mac ipad iphone作为接收，以此来随地接收文件 一台win11+ubuntu24的双系统电脑+西部数据4t紫盘机械硬盘+绿联硬盘盒</p> <p>机械硬盘在刚买回来的时候要进行初始化，我用的是mac的磁盘工具对他进行“抹掉” 然后为其分配一个文件系统这里我选择exFAT，因为这个格式对不同的操作系统兼容性更强</p> <p>一开时用了绿联的硬盘盒将机械硬盘装进去用usb3.0数据线连接到linux电脑上</p> <h4 id="samba"><strong>Samba</strong></h4> <p>然后在linux上要安装Samba（用于文件共享）</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install </span>samba
</code></pre></div></div> <p>用vim编辑Samba配置文件</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vim /etc/samba/smb.conf
</code></pre></div></div> <p>在文件末尾添加一下内容</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>MyNAS]
path <span class="o">=</span> /path/to/your/harddrive//这里是你机械硬盘在你电脑的位置，可以在图形化界面打开这个机械硬盘然后再在终端中看他的路径，像我的就在/media/laurie/HDD
available <span class="o">=</span> <span class="nb">yes
</span>valid <span class="nb">users</span> <span class="o">=</span> laurie//这里可以自己填用户名
<span class="nb">read </span>only <span class="o">=</span> no
browsable <span class="o">=</span> <span class="nb">yes
</span>public <span class="o">=</span> <span class="nb">yes
</span>writable <span class="o">=</span> <span class="nb">yes</span>
</code></pre></div></div> <p>然后保存退出 然后创建一个Samba用户，会要求你输入一个密码</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>smbpasswd <span class="nt">-a</span> laurie//这里的用户名填上面配置的用户名
</code></pre></div></div> <p>然后重启Samba服务</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl restart smbd
</code></pre></div></div> <h4 id="zerotier"><strong>ZeroTier</strong></h4> <h5 id="linux">linux</h5> <p>然后进行内网穿透的话我使用ZeroTier，原理的话可以自行chatgpt 首先在linux上安装zerotier</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-s</span> https://install.zerotier.com | <span class="nb">sudo </span>bash
</code></pre></div></div> <p>启动zerotier服务</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>systemctl <span class="nb">enable </span>zerotier-one
<span class="nb">sudo </span>systemctl start zerotier-one
</code></pre></div></div> <p>然后访问<a href="https://www.zerotier.com">zerotier</a>创建一个账号，然后创建一个新的虚拟网络 创建完之后会得到一个NEetwork ID 这里用哪一个设备进行创建都可以 然后在linux中加入ZeroTier网络</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>zerotier-cli <span class="nb">join</span> &lt;Network ID&gt;
</code></pre></div></div> <p>进入 ZeroTier Central，找到刚刚加入的设备，勾选旁边的复选框，批准该设备加入网络 然后可以在那个界面看到zerotier为你分配的managed ip</p> <h5 id="mac">Mac</h5> <p>然后现在要保证你要连接的设备和你的nas在同一个网络中 在mac上用命令行安装ZeroTier（也可以下载ZeroTier app 我是用的命令行）</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>zerotier-one
</code></pre></div></div> <p>安装完后启动zerotier服务</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>zerotier-cli <span class="nb">join</span> &lt;Network ID&gt;
</code></pre></div></div> <p>在zerotier网站上检查是否已经添加成功</p> <h5 id="ipadiphone">ipad&amp;iphone</h5> <p>在这两个设备下要下载zerotier app外区的app store有的下，然后点击+号，输入network id来加入网络</p> <h4 id="finder"><strong>Finder</strong></h4> <p>最后就是利用苹果的finder来对硬盘中的文件进行访问</p> <h5 id="mac-1">MAC</h5> <p>command+k然后弹出连接服务器窗口 在搜索栏里填写smb://<虚拟ip>/&lt;Samba配置文件添加内容的那个头名字，在我的上面的例子中就是MyNas&gt; 然后填写nas的用户名和密码就可以连接</虚拟ip></p> <h5 id="win">Win</h5> <p>可以打开文件资源管理器，直接在地址栏中输入以下格式：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="se">\\</span>&lt;你的Managed IP&gt;<span class="se">\&lt;</span>共享文件夹&gt;
</code></pre></div></div> <p>没试过不保证成功率</p> <h5 id="ipadiphone-1">Ipad&amp;iphone</h5> <p>在文件中找到添加服务器 然后也按照这个格式smb://<虚拟ip>/&lt;Samba配置文件添加内容的那个头名字，在我的上面的例子中就是MyNas&gt;填写</虚拟ip></p> <p>但是iphone好像会不是很稳定，目前还没找到解决办法</p> <h4 id="shell"><strong>shell</strong></h4> <p>当然也可以用ssh远程连接</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shell <span class="nb">hostname</span>@虚拟ip
</code></pre></div></div> <p>就可以连接</p> <h4 id="总结"><strong>总结</strong></h4> <p>至此我们就搭建了nas服务器，最后如果遇到什么问题请问chatgpt他才是世界上最好的老师</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="其他"/><summary type="html"><![CDATA[build nas by a computer and HDD]]></summary></entry><entry><title type="html">Discrete Mathematics lecture3</title><link href="https://laurie-hxf.github.io/blog/2024/Discrete-Mathematics-lecture3/" rel="alternate" type="text/html" title="Discrete Mathematics lecture3"/><published>2024-10-13T06:46:00+00:00</published><updated>2024-10-13T06:46:00+00:00</updated><id>https://laurie-hxf.github.io/blog/2024/Discrete-Mathematics-lecture3</id><content type="html" xml:base="https://laurie-hxf.github.io/blog/2024/Discrete-Mathematics-lecture3/"><![CDATA[<h3 id="cardinality-of-sets基数">Cardinality of sets(基数)</h3> <p>A和B有相同的基数如果A和B之间是双射的（bijection）-&gt;表示为|A|=|B|</p> <h5 id="schröder-bernstein-theorem">Schröder-Bernstein Theorem</h5> <p>如果有一个单射函数 f:$A \rightarrow B$ 和一个单射函数 g：$B \rightarrow A$ 那么就可以说明存在一个双射函数在A和B之间 （A和B都可以是无穷的）-&gt;|A|=|B| \(例子\) \(f: (0,1) \rightarrow (0,1]\quad f(x)=x\) \(g:(0,1] \rightarrow (0,1)\quad g(x)=\frac{x}{2}\)</p> <h5 id="countable-and-uncountable-sets">countable and uncountable sets</h5> <p>countable:有限集合或者集合的基数和$Z^+$一样 uncountable：反之就是uncountable</p> <h6 id="如何证明一个集合是countable">如何证明一个集合是countable：</h6> <ol> <li>证明存在两个单射函数从$Z^+ \rightarrow A$以及从$A \rightarrow Z^+$</li> <li>直接列出一个序列 <mark>eg1</mark> :证明Z是countable $list a sequence：0,1,-1,2,-2…$ <mark>eg2</mark> :证明有理数是countable <blockquote> <p>列出所有可能 $\frac{1}{1}\quad \frac{2}{1}\quad \frac{3}{1}\quad \frac{4}{1}\quad\frac{5}{1}\quad …$ $\frac{1}{2}\quad \frac{2}{2}\quad \frac{3}{2}\quad \frac{4}{3}\quad\frac{4}{1}\quad …$ $\frac{1}{3}\quad \frac{2}{3}\quad \frac{3}{3}\quad \frac{4}{3}\quad\frac{5}{3}\quad …$</p> </blockquote> </li> </ol> <h3 id="如何证明一个集合是uncountable">如何证明一个集合是uncountable</h3> <p>$Cantor’s: diagonal: argument$</p> <blockquote> <p>Assume that R is countable. Then, every subset of R is countable . In particular, interval[0, 1] is countable. This implies that there exists a list $r_1, r_2, r_3, …$that can enumerate all elements in this set, where $r_1 =\textcolor{red}{0.d_{11}} d_{12} d_{13}…$ $r_2 =0.d_{21} \textcolor{red}{d_{22}} d_{23}…$ $r_3 =0.d_{31} d_{32} \textcolor{red}{d_{33}}…$ $…$ 然后构造一个使得他的他的第i个数和$r_i$的第i个元素都不一样</p> </blockquote> <p><mark>eg</mark>证明𝒫(N)的power set是uncountable Proof by contradiction: (Cantor’s diagonal argument) • Assume that 𝒫(N) is countable. This means that all elements of this set can be listed as $S_0, S_1, S_2, …$,where $S_i∈ \mathcal{P}(N)$. Then, each $S_i⊆ N$ can be represented by a bit string $b_{i0}b_{i1}b_{i2}···$, where $b_{ij}= 1$ if $j ∈ S_i \quad and\quad b_{ij}=0 \quad if \quad j ∉ Si:$ $S_0= \textcolor{red} {b_{00}}b_{01}b_{02}b_{03}…$ $S_1= b_{00}\textcolor{red}{b_{01}}b_{02}b_{03}…$ $S_2= b_{20}b_{21}\textcolor{red}{b_{22}}b_{23}…$ $…$ 大致意思就是将N的子集$S_i$用0101序列表示，1表示该子集存在某个元素 然后N的所有子集就可以变为一个01序列，然后用$Cantor’s: diagonal: argument$证明存在一个$S_i$不在那个序列中</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="数学"/><summary type="html"><![CDATA[Discrete Mathematics lecture3]]></summary></entry><entry><title type="html">the details about this blog</title><link href="https://laurie-hxf.github.io/blog/2024/the-details-about-this-blog/" rel="alternate" type="text/html" title="the details about this blog"/><published>2024-09-15T12:22:00+00:00</published><updated>2024-09-15T12:22:00+00:00</updated><id>https://laurie-hxf.github.io/blog/2024/the-details-about-this-blog</id><content type="html" xml:base="https://laurie-hxf.github.io/blog/2024/the-details-about-this-blog/"><![CDATA[<p>本博客基于github pages中的al-folio为主题</p> <p>就记录一下配置这篇博客的细节 以便以后需要重新配置之后可以节约时间</p> <p>主题网站：https://github.com/alshedivat/al-folio</p> <p>样例：https://alshedivat.github.io/al-folio/</p> <p>安装该主题：https://github.com/alshedivat/al-folio/blob/master/INSTALL.md （最开始配置可以看里面的视频）</p> <p>修改该主题：https://github.com/alshedivat/al-folio/blob/master/CUSTOMIZE.md</p> <p>giscus评论：https://giscus.app/zh-CN</p> <p>git pages: https://pages.github.com</p> <p>jekll官网 :https://jekyllrb.com （里面有各种主题）</p> <p>温馨提示：当每次修改本地仓库的内容后，将它push到远程仓库，一般要等待几分钟，不用额外对github进行操作，最好在你要改变一些东西的时候连同改变一些像news的内容，这样你就可以判断你要改的东西有没有成功部署 最后善用gpt 一切不懂的都可以问他 以及千万不能在这个blog文件夹中新建文件夹，否则不知道会出什么混乱 以及每次写完一篇博客或news的时候，一定要注意那里的时间是不是当前的时间，如果是以后的时间，他有可能要等到那个时间才会展现出来。</p> <h3 id="编写">编写</h3> <p>这篇博客有一个本地仓库，通过本地git仓库与github仓库远程连接，然后通过vscode进行本地编写</p> <h3 id="评论">评论</h3> <p>本博客的评论是基于主题自带的评论，（位于_config.yml文件中Giscus comments），配置教程<a href="https://giscus.app/">这个</a>首先创建一个public的仓库用来存储评论，并且在setting中设置允许discussion功能，具体可看官网教程。当填写仓库和discussion选项之后会在下面生成一段代码，然后将_config文件根据生成代码填写。之后有一步很重要的操作就是将那段代码复制粘贴到_layouts/default.liquid文件最下面（记住要放在&lt;body&gt;中）原因就是要在default中再生成一个新区间，才能反应到前段中。</p> <h3 id="主页">主页</h3> <p>主页中的内容一部分是在_pages/about.md中修改（包括自我陈述，图片下面的文字），还有一部分是在_config.yml中修改（包括名字的修改），头像的话在assets/img中将想要展现的头像重命名为prof_pic.jpg</p> <h3 id="news">news</h3> <p>在_news中添加文件，格式的话最简单就是在之前的文件里更改或者按照之前的文件进行更改</p> <h3 id="子目录">子目录</h3> <p>子目录的管理在_pages文件夹中，原本的样例网站中有很多个子目录，可以选择是否显示这些目录</p> <h5 id="blog">blog</h5> <p>这个子目录下的最上层文字在_config.yml文件blog那里编辑，包括下面的tag，可以添加tag选项，然后要写blog的话就在_post文件夹中增加文件，文件名格式为year-month-day-blogname.md，然后具体写博客的话可以参考原本的模版进行修改，同时可以对每篇博客添加tag以便进行分类查找。</p> <h5 id="repositories">repositories</h5> <p>这个在_data/repositories中配置</p> <h5 id="cv">cv</h5> <p>具体的cv内容可以从assets/json/resume.json中进行修改，参考<a href="https://github.com/alshedivat/al-folio/blob/master/CUSTOMIZE.md">主题网站</a>中有提到怎么修改</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="其他"/><summary type="html"><![CDATA[the details about this blog]]></summary></entry><entry><title type="html">about this blog</title><link href="https://laurie-hxf.github.io/blog/2024/About-this-blog/" rel="alternate" type="text/html" title="about this blog"/><published>2024-09-09T16:00:00+00:00</published><updated>2024-09-09T16:00:00+00:00</updated><id>https://laurie-hxf.github.io/blog/2024/About-this-blog</id><content type="html" xml:base="https://laurie-hxf.github.io/blog/2024/About-this-blog/"><![CDATA[<p>这个博客是基于<a href="https://pages.github.com">github pages</a>平台搭建 他以<a href="https://jekyllrb.com">Jekyll</a>中的<a href="https://github.com/alshedivat/al-folio">这个</a>为主题 可以根据其中的README file来下载使用，听起来简单，实际上非常的繁琐复杂，有大量莫名其妙的格式（主要还是jekyll） 需要学习，模仿，还需要根据自己需求进行调试，而且这个主题的引导做的对新手不是特别友好（反正我调试了好几天）</p> <p>然后的话一开始搭建这个博客的话也尝试过hexo+cloudfare进行搭建（根据<a href="https://blog.cuijiacai.com/blog-building/">这篇博客</a>）进行搭建 需要购买域名，但最终嫌弃hexo上面的主题太丑，而且github pages不需要购买域名，主题也更多，所以最终选择github pages。好吧还有一部分原因是购买域名的话 还要解析等等一系列很懵逼的操作，跟着博客做很知其然不知其所然（等我学完计网再来吧），不如好好读读README file，但说实话在github pages 上面搭建会非常的慢，当你在你的仓库中更改一点东西时，可以要等好几分钟才能在github.io上展现出来</p> <p>其实做这个博客的初衷呢也是看到很多佬有自己的博客分享他们的经验，学习方法什么的，我也就来凑凑热闹。主要面向对象还是自己，可能会自言自语，会写一些技术笔记， 分享一些学习资料的一些整理，学习感悟。</p> <p>后面的话应该还会部署git talk方便有什么想法可以留言</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="其他"/><summary type="html"><![CDATA[something about this blog]]></summary></entry></feed>